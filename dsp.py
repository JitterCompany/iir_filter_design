import numpy as np
from collections import namedtuple

StandardSOS = namedtuple('StandardSOS',
        ['b0', 'b1', 'b2','a0', 'a1', 'a2'])

def dsp2antoniou(c):
    """ Translates second order filter sections from DSP-convention
    format (StandardSOS) to optimized Antoniou format.
    
    parameters
    ----------
    
    c: arraylike
        Second order stage with the following order:
        
        [b0, b1, b2, a0, a1, a2] such that
        
           b0 + b1*z^-1 + b2*z^-2
    H(z) = ----------------------
           1  + a1*z^-1 + a2*z^-2
            
    returns
    -------
    
    (coeffs, H): tuple
        coefs = [a0, a1, b1, b2] and H the multiplier such that
        
              a0 + a1z + z^2
    H(z) = H  --------------
              b0 + b1z + z^2
        
    """
    
    c = StandardSOS(*c)

    H = c.b0
    # numerator
    a0 = c.b2 / H
    a1 = c.b1 / H
    # a2 = c.b0 = 1
    
    # denominator
    b0 = c.a2
    b1 = c.a1
    # b2 = c.a0 = 1
    
    return [a0, a1, b0, b1], H


def simplify_biquad_filters(system):
    """
    Converts array of N standard second order stages (SOS) such as generated by scipy.signal into
    optimized filter coefficient format.
    
    parameters
    ----------
    
    system: list of standard format sos
            
            [[b0, b1, b2, a0, a1, a2], [b0, b1, b2, a0, a1, a2], ... ]
    
    returns
    -------
    
    coeffs: ndarray
        [a_01 a_11 b_01 b_11 ... b_0N b_1N H0]
        
    Where a_01 a_11 b_01 b_11 are the coefficients for stage 1 and a_02 a_12 b_02 b_12 for stage 2, etc. 

    
                  N   a0j + a1jz + z^2
    H(c, z) = H0  ∏   ----------------, 
                 j=0  b0j + b1jz + z^2
                 
    for j = range(1, N)
        
    """
    a = [dsp2antoniou(sos) for sos in system]
    coeffs, Hm = list(zip(*a))
    H0 = np.product(Hm)
    return np.r_[np.concatenate(coeffs), H0]



def group_delay(c, w):
    """
    Calculates the group delay for filter with coefficients c for the given frequencies in w
    
    Parameters
    ----------
    
    c: ndarray
        list of all coefficients of all seconds order stages:
        [a_01 a_11 b_01 b_11 ... b_0N b_1N H0]

    w: ndarray
        frequency bins in the range [0, π] to evaluate the group delay on

    """
    
    J = len(c) // 4 # num stages: we don't use H0 = c[-1]
    group_delay = 0
    for i in range(0, J*4, 4):

        a0, a1, b0, b1 = c[i:i+4]

        alpha_n = 1 - a0**2 + a1*(1 - a0) * np.cos(w)
        beta_n = a0**2 + a1**2 + 1 + 2*a0*1*(2*np.cos(w)**2 - 1) + 2*a1*(a0 + 1)*np.cos(w)
        alpha_d = 1 - b0**2 + b1*(1 - b0)*np.cos(w)
        beta_d =  b0**2 + b1**2 + 1 + 2*b0*1*(2*np.cos(w)**2 - 1) + 2*b1*(b0 + 1)*np.cos(w)

        group_delay += -alpha_n/beta_n + alpha_d/beta_d

    return group_delay

def group_delay_deviation(x, w):
    """
    Calculates the group delay deviation for filter with coefficients x for the given frequencies in w
    
    parameters
    ----------
    
    x: ndarray
        list of all coefficients of all seconds order stages and tau, the group delay optimization variable:
        [c tau]

    w: ndarray
        frequency bins in the range [0, π] to evaluate the group delay on

    """
    
    J = (len(x) - 2) // 4 # num stages: we don't use H0 = c[-2], tau is c[-1] 
    tau = x[-1]
    group_delay = 0
    for i in range(0, J*4, 4):

        a0, a1, b0, b1 = x[i:i+4]

        alpha_n = 1 - a0**2 + a1*(1 - a0) * np.cos(w)
        beta_n = a0**2 + a1**2 + 1 + 2*a0*1*(2*np.cos(w)**2 - 1) + 2*a1*(a0 + 1)*np.cos(w)
        alpha_d = 1 - b0**2 + b1*(1 - b0)*np.cos(w)
        beta_d =  b0**2 + b1**2 + 1 + 2*b0*1*(2*np.cos(w)**2 - 1) + 2*b1*(b0 + 1)*np.cos(w)

        group_delay += -alpha_n/beta_n + alpha_d/beta_d

    return group_delay - tau

def H_eval(c, w):
    """ Evaluates the filter transfer function for each frequency in w.

    Parameters
    ----------
     c: ndarray
        list of all coefficients of all seconds order stages:
        [a_01 a_11 b_01 b_11 ... b_0N b_1N H0]
            
    w : ndarray
        frequency bins between 0 and 2π
        
    Returns
    -------
    
    H: ndarray with dtype 'complex128'
    
    """

    H0 = c[-1]
    _H = np.ones(len(w), dtype='complex128')
    J = len(c) // 4 # number of 2nd order filter sections
    for i in range(0, J*4, 4):
        a0, a1, b0, b1 = c[i:i+4]
        _H *= (a0 + a1*np.exp(1j*w) + np.exp(2*1j*w)) / (b0 + b1*np.exp(1j*w) + np.exp(2*1j*w))
    return H0 * _H

def H_mag_squared(c, w):
    """ 
    Calculcate the squared magnitude response of the filter.
    """
    return np.abs(H_eval(c,w))**2

